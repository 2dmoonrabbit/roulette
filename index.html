<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>레몬 룰렛</title>
  <style>
    :root { --size: 380px; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
      background:
        radial-gradient(900px 700px at 50% 30%, rgba(255,235,160,.65) 0%, rgba(255,235,160,0) 48%),
        radial-gradient(1100px 900px at 50% 120%, rgba(180,210,140,.35) 0%, rgba(180,210,140,0) 55%),
        linear-gradient(180deg, #f6f0dc 0%, #efe6c7 40%, #f8f4e7 100%);
      color:#1c2130;
    }
    .wrap{ display:flex; flex-direction:column; align-items:center; gap:14px; padding:24px; }
    .wheel-wrap{ position:relative; width:var(--size); height:var(--size); }
    canvas{
      width:100%; height:100%; border-radius:50%;
      box-shadow: 0 18px 55px rgba(0,0,0,.20);
      background: rgba(255,255,255,.25);
    }
    .pin{
      position:absolute; top:-8px; left:50%; transform:translateX(-50%);
      width:0; height:0;
      border-left:14px solid transparent;
      border-right:14px solid transparent;
      border-top:26px solid #1c2130;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.18));
    }
    button{
      padding:12px 18px; border:0; border-radius:14px; cursor:pointer;
      font-weight:900; font-size:16px; background:#1c2130; color:#fff;
      box-shadow: 0 10px 25px rgba(0,0,0,.18);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .result{ font-size:18px; font-weight:900; color:#1c2130; }
    .badge{
      position:fixed; top:14px; left:14px;
      padding:8px 10px; border-radius:12px;
      background: rgba(255,255,255,.60);
      border:1px solid rgba(0,0,0,.08);
      backdrop-filter: blur(8px);
      font-weight:900; font-size:12px;
      color:#1c2130;
    }
  </style>
</head>
<body>
  <div class="badge">UPDATED v4 (labels fixed inside + warmer/orange sections)</div>

  <div class="wrap">
    <div class="wheel-wrap">
      <div class="pin"></div>
      <canvas id="wheel" width="840" height="840"></canvas>
    </div>

    <button id="spinBtn" disabled>SPIN</button>
    <div class="result" id="result">결과: -</div>
  </div>

<script>
  const outcomes = [
    { label: "x3",  p: 3  },
    { label: "x2",  p: 5  },
    { label: "x0",  p: 10 },
    { label: "x1",  p: 80 },
    { label: "x-2", p: 2  },
  ];

  const IMAGE_ZOOM = 1.45;
  const SPIN_DURATION_MS = 3200;
  const MIN_TURNS = 7;
  const EXTRA_TURNS_RANGE = 2;

  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const spinBtn = document.getElementById("spinBtn");
  const resultEl = document.getElementById("result");

  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;
  const r  = Math.min(W,H)/2 - 22;

  const TAU = Math.PI * 2;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  const wheelImg = new Image();
  wheelImg.src = "lemon.png";
  wheelImg.onload = () => { draw(angle); spinBtn.disabled = false; };
  wheelImg.onerror = () => { resultEl.textContent = "이미지 로드 실패: lemon.png 파일명/경로 확인"; };

  // sectors by probability (angles)
  const totalP = outcomes.reduce((a,b)=>a+b.p,0);
  const sectors = [];
  let acc = 0;
  const startBase = -Math.PI / 2;
  for (let i=0; i<outcomes.length; i++){
    const span = (outcomes[i].p / totalP) * TAU;
    const start = startBase + acc;
    const end = start + span;
    sectors.push({ i, start, end, mid: (start+end)/2, span });
    acc += span;
  }

  function pickSectorIndex(){
    const x = Math.random() * totalP;
    let s = 0;
    for (let i=0;i<outcomes.length;i++){
      s += outcomes[i].p;
      if (x < s) return i;
    }
    return outcomes.length - 1;
  }

  let angle = 0;
  let spinning = false;

  function draw(a){
    ctx.clearRect(0,0,W,H);

    // outer ring
    ctx.beginPath();
    ctx.arc(cx,cy,r+9,0,TAU);
    ctx.fillStyle = "rgba(0,0,0,.06)";
    ctx.fill();

    // --- wheel (rotates) ---
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(a);

    // clip
    ctx.beginPath();
    ctx.arc(0,0,r,0,TAU);
    ctx.clip();

    // image cover + zoom
    const imgW = wheelImg.width, imgH = wheelImg.height;
    const baseScale = Math.max((r*2)/imgW, (r*2)/imgH);
    const scale = baseScale * IMAGE_ZOOM;
    ctx.drawImage(wheelImg, -imgW*scale/2, -imgH*scale/2, imgW*scale, imgH*scale);

    // slight dim
    ctx.fillStyle = "rgba(0,0,0,.06)";
    ctx.fillRect(-r,-r,r*2,r*2);

    // ✅ warmer/orange section overlays (more visible)
    for (let k=0;k<sectors.length;k++){
      const s = sectors[k];
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,r,s.start,s.end);
      ctx.closePath();
      // alternate warm overlays
      ctx.fillStyle = (k%2===0)
        ? "rgba(255, 168, 74, .14)"   // orange
        : "rgba(255, 230, 150, .10)"; // warm yellow
      ctx.fill();
    }

    // boundaries (warm highlight)
    for (const s of sectors){
      // shadow line
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(s.start)*r, Math.sin(s.start)*r);
      ctx.lineWidth = 7;
      ctx.strokeStyle = "rgba(120,70,0,.20)";
      ctx.stroke();

      // highlight line
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(s.start)*r, Math.sin(s.start)*r);
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(255,255,255,.70)";
      ctx.stroke();
    }
    const last = sectors[sectors.length-1];
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(Math.cos(last.end)*r, Math.sin(last.end)*r);
    ctx.lineWidth = 7;
    ctx.strokeStyle = "rgba(120,70,0,.20)";
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(Math.cos(last.end)*r, Math.sin(last.end)*r);
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,.70)";
    ctx.stroke();

    ctx.restore();

    // ✅ labels FIX: draw in screen coords so they stay INSIDE each sector (no drifting)
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for (const s of sectors){
      const pct = outcomes[s.i].p;
      const fontSize = Math.round(clamp(44 * (s.span / (TAU/5)), 18, 38));
      const radiusFactor = pct <= 5 ? 0.80 : (pct <= 10 ? 0.72 : 0.60);

      const theta = a + s.mid;              // rotate with wheel
      const x = cx + Math.cos(theta) * (r * radiusFactor);
      const y = cy + Math.sin(theta) * (r * radiusFactor);

      ctx.save();
      ctx.translate(x,y);
      // rotate text to follow wheel (readable-ish)
      ctx.rotate(theta + Math.PI/2);
      ctx.fillStyle = "#ffffff";
      ctx.font = `900 ${fontSize}px system-ui, -apple-system, 'Noto Sans KR', sans-serif`;
      ctx.shadowColor = "rgba(0,0,0,.40)";
      ctx.shadowBlur = 10;
      ctx.fillText(outcomes[s.i].label, 0, 0);
      ctx.restore();
    }
    ctx.restore();

    // center cap
    ctx.beginPath();
    ctx.arc(cx,cy,74,0,TAU);
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.fill();
    ctx.lineWidth = 10;
    ctx.strokeStyle = "rgba(0,0,0,.10)";
    ctx.stroke();
  }

  spinBtn.addEventListener("click", () => {
    if (spinning) return;
    if (!wheelImg.complete) return;

    spinning = true;
    spinBtn.disabled = true;
    resultEl.textContent = "결과: ...";

    const picked = pickSectorIndex();
    const sec = sectors.find(s => s.i === picked);

    const currentMod = ((angle % TAU) + TAU) % TAU;
    const desiredMod = ((-Math.PI/2 - sec.mid) % TAU + TAU) % TAU;
    let delta = desiredMod - currentMod;
    if (delta < 0) delta += TAU;

    const turns = (MIN_TURNS + Math.floor(Math.random()*EXTRA_TURNS_RANGE)) * TAU;
    const target = angle + turns + delta;

    const start = performance.now();
    const dur = SPIN_DURATION_MS;
    const startAngle = angle;
    const easeOut = t => 1 - Math.pow(1-t,3);

    function anim(now){
      const t = Math.min(1, (now - start)/dur);
      angle = startAngle + (target - startAngle) * easeOut(t);
      draw(angle);
      if (t < 1) requestAnimationFrame(anim);
      else{
        spinning = false;
        spinBtn.disabled = false;
        resultEl.textContent = `결과: ${outcomes[picked].label} (확률 ${outcomes[picked].p}%)`;
      }
    }
    requestAnimationFrame(anim);
  });
</script>
</body>
</html>
