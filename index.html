<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>레몬 룰렛</title>
  <style>
    :root { --size: 380px; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
      background: radial-gradient(900px 600px at 50% 30%, #2b2a1a 0%, #141826 55%, #0b0f16 100%);
      color:#fff;
    }
    .wrap{ display:flex; flex-direction:column; align-items:center; gap:14px; padding:24px; }
    .wheel-wrap{ position:relative; width:var(--size); height:var(--size); }
    canvas{ width:100%; height:100%; border-radius:50%; box-shadow:0 16px 55px rgba(0,0,0,.55); }
    /* ✅ 역삼각형(아래를 가리킴) */
    .pin{
      position:absolute; top:-6px; left:50%; transform:translateX(-50%);
      width:0; height:0;
      border-left:14px solid transparent;
      border-right:14px solid transparent;
      border-top:26px solid #ffffff;
      filter: drop-shadow(0 10px 16px rgba(0,0,0,.55));
    }
    button{
      padding:12px 18px; border:0; border-radius:14px; cursor:pointer;
      font-weight:800; font-size:16px; background:#fff; color:#111;
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .result{ font-size:18px; font-weight:800; }

    /* ✅ 업데이트 확인용 배지 (페이지에 꼭 보임) */
    .badge{
      position:fixed; top:14px; left:14px;
      padding:8px 10px; border-radius:12px;
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(8px);
      font-weight:800; font-size:12px; letter-spacing:.2px;
    }
  </style>
</head>
<body>
  <div class="badge">UPDATED v2 (triangle inverted + sector lines + lemon-bg)</div>

  <div class="wrap">
    <div class="wheel-wrap">
      <div class="pin"></div>
      <canvas id="wheel" width="840" height="840"></canvas>
    </div>

    <button id="spinBtn" disabled>SPIN</button>
    <div class="result" id="result">결과: -</div>
  </div>

<script>
  const outcomes = [
    { label: "x3",  p: 3  },
    { label: "x2",  p: 5  },
    { label: "x0",  p: 10 },
    { label: "x1",  p: 80 },
    { label: "x-2", p: 2  },
  ];

  const IMAGE_ZOOM = 1.45;

  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const spinBtn = document.getElementById("spinBtn");
  const resultEl = document.getElementById("result");

  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;
  const r  = Math.min(W,H)/2 - 22;

  const wheelImg = new Image();
  wheelImg.src = "lemon.png";

  wheelImg.onload = () => { draw(angle); spinBtn.disabled = false; };
  wheelImg.onerror = () => { resultEl.textContent = "이미지 로드 실패: lemon.png 파일명/경로 확인"; };

  const totalP = outcomes.reduce((a,b)=>a+b.p,0);
  const sectors = [];
  let acc = 0;
  const startBase = -Math.PI / 2;

  for (let i=0; i<outcomes.length; i++){
    const span = (outcomes[i].p / totalP) * Math.PI * 2;
    const start = startBase + acc;
    const end = start + span;
    sectors.push({ i, start, end, mid: (start+end)/2, span });
    acc += span;
  }

  function pickSectorIndex(){
    const x = Math.random() * totalP;
    let s = 0;
    for (let i=0;i<outcomes.length;i++){
      s += outcomes[i].p;
      if (x < s) return i;
    }
    return outcomes.length - 1;
  }

  let angle = 0;
  let spinning = false;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  function draw(a){
    ctx.clearRect(0,0,W,H);

    // outer ring
    ctx.beginPath();
    ctx.arc(cx,cy,r+9,0,Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fill();

    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(a);

    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.clip();

    // image cover + zoom
    const imgW = wheelImg.width, imgH = wheelImg.height;
    const baseScale = Math.max((r*2)/imgW, (r*2)/imgH);
    const scale = baseScale * IMAGE_ZOOM;
    ctx.drawImage(wheelImg, -imgW*scale/2, -imgH*scale/2, imgW*scale, imgH*scale);

    // dim slightly
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(-r,-r,r*2,r*2);

    // sector overlay (very light)
    for (let k=0;k<sectors.length;k++){
      const s = sectors[k];
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,r,s.start,s.end);
      ctx.closePath();
      ctx.fillStyle = (k%2===0) ? "rgba(255,255,255,.06)" : "rgba(255,255,255,.02)";
      ctx.fill();
    }

    // boundary lines (light)
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(255,255,255,.35)";
    for (const s of sectors){
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(s.start)*r, Math.sin(s.start)*r);
      ctx.stroke();
    }
    const last = sectors[sectors.length-1];
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(Math.cos(last.end)*r, Math.sin(last.end)*r);
    ctx.stroke();

    // labels (auto shrink & position)
    for (const s of sectors){
      const pct = outcomes[s.i].p;
      const fontSize = Math.round(clamp(48 * (s.span / (Math.PI*2/5)), 22, 44));
      const radiusFactor = pct <= 5 ? 0.80 : (pct <= 10 ? 0.72 : 0.62);

      ctx.save();
      ctx.rotate(s.mid);
      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.font = `900 ${fontSize}px system-ui, -apple-system, 'Noto Sans KR', sans-serif`;
      ctx.shadowColor = "rgba(0,0,0,.60)";
      ctx.shadowBlur = 10;
      ctx.fillText(outcomes[s.i].label, 0, -r*radiusFactor);
      ctx.restore();
    }

    ctx.restore();

    // center cap
    ctx.beginPath();
    ctx.arc(cx,cy,86,0,Math.PI*2);
    ctx.fillStyle = "rgba(15,18,32,.92)";
    ctx.fill();
    ctx.lineWidth = 10;
    ctx.strokeStyle = "rgba(255,255,255,.30)";
    ctx.stroke();
  }

  spinBtn.addEventListener("click", () => {
    if (spinning) return;
    if (!wheelImg.complete) return;

    spinning = true;
    spinBtn.disabled = true;
    resultEl.textContent = "결과: ...";

    const picked = pickSectorIndex();
    const sec = sectors.find(s => s.i === picked);

    const extraTurns = (6 + Math.floor(Math.random()*2)) * Math.PI * 2;
    const target = extraTurns + (-Math.PI/2 - sec.mid);

    const start = performance.now();
    const dur = 2600;
    const startAngle = angle;
    const easeOut = t => 1 - Math.pow(1-t,3);

    function anim(now){
      const t = Math.min(1, (now - start)/dur);
      angle = startAngle + (target - startAngle) * easeOut(t);
      draw(angle);
      if (t < 1) requestAnimationFrame(anim);
      else{
        spinning = false;
        spinBtn.disabled = false;
        resultEl.textContent = `결과: ${outcomes[picked].label} (확률 ${outcomes[picked].p}%)`;
      }
    }
    requestAnimationFrame(anim);
  });
</script>
</body>
</html>
